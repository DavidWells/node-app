{
  "name": "asynquence-contrib",
  "version": "0.2.3-a",
  "description": "contrib plugins for asynquence",
  "main": "./contrib.js",
  "scripts": {
    "test": "./node-tests.js",
    "bundle": "./bundle.js"
  },
  "peerDependencies": {
    "asynquence": "*"
  },
  "devDependencies": {
    "uglify-js": "~2.4.8",
    "native-promise-only": "latest"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/getify/asynquence.git"
  },
  "keywords": [
    "async",
    "flow-control",
    "sequences",
    "promise",
    "iterator",
    "generator"
  ],
  "bugs": {
    "url": "https://github.com/getify/asynquence/issues",
    "email": "getify@gmail.com"
  },
  "homepage": "https://github.com/getify/asynquence/blob/master/contrib",
  "author": {
    "name": "Kyle Simpson",
    "email": "getify@gmail.com"
  },
  "license": "MIT",
  "readme": "# asynquence Contrib\n\nOptional plugin helpers are provided in `/contrib/*`. The full bundle of plugins (`contrib.js`) is **~2.2k** minzipped.\n\nGate variations:\n\n* `all(..)` is **an alias** of `gate(..)`.\n* `any(..)` is like `gate(..)`, except **just one segment** *has* to succeed to proceed on the main sequence.\n* `first(..)` is like `any(..)`, except **as soon as any segment succeeds**, the main sequence proceeds (ignoring subsequent results from other segments).\n* `last(..)` is like `any(..)`, except only **the latest segment to complete successfully** sends message(s) along to the main sequence.\n* `none(..)` is the inverse of `gate(..)`: the main sequence proceeds only **if all the segments fail** (with all segment error message(s) transposed as success message(s) and vice versa).\n* `map(arr, eachFn)` allows an asynchronous mapping of an array's values to another set of values. `map(..)` constructs a gate of segments, one for each item in `arr`. Each segment invokes `eachFn(..)` for the respective item in the array.\n\n    `eachFn(item, doneTrigger, ..)` receives the respective `item` in the array and a `doneTrigger` to invoke with the new value to map back to that array position. **Note:** If multiple values are passed, that item's value will be an array (*asynquence* message wrapper) collection of the values passed.\n\n    Just like with normal gates, `eachFn(..)` also receives any sequence messages passed forward from the previous main sequence step, such as `eachFn(item, doneTrigger, msg1, msg2, ..)`. And, if any segment causes an error, the rest of the `map(..)` fails and the main sequence is flagged as error'd.\n\n    If either `arr`, `eachFn` or both are not passed to `map(..)`, it will attempt to pull them from the value-message stream it received from the previous step. Even if it does so, any subsequent messages in the stream will still pass on to the `eachFn` callback.\n\n    The final success message from a `map(..)` sequence step is the newly constructed array of mapped values.\n\nSequence-step variations:\n\n* `until(..)` is like `then(..)`, except it **keeps re-trying until success** or `break()` (for loop semantics) before the main sequence proceeds.\n* `try(..)` is like `then(..)`, except it proceeds as success on the main sequence **regardless of success/failure signal**. If an error is caught, it's transposed as a special-format success message: `{ catch: ... }`.\n* `waterfall(..)` is like a sequence of `then(..)`s, except the output from each step is tracked, and the aggregate of all steps' success messages thus far is the input messages to the next step (step 3 gets passed success output from both 1 and 2, etc). Thus, the final output success message(s) of `waterfall(..)` is the collection of all success messages from the waterfall's steps.\n\n    An error anywhere along the waterfall behaves like an error in any sequence, immediately jumping to error state and aborting any further success progression.\n\n### `iterable-sequence` Plugin\n\n`iterable-sequence` plugin provides `ASQ.iterable()` for creating iterable sequences. See [Iterable Sequences](https://github.com/getify/asynquence/blob/master/README.md#iterable-sequences) for more information, and examples: [sync loop](https://gist.github.com/getify/8211148#file-ex1-sync-iteration-js) and [async loop](https://gist.github.com/getify/8211148#file-ex2-async-iteration-js).\n\n### `toPromise` Plugin\n\n`toPromise` plugin provides `.toPromise()` (takes zero parameters) on a *asynquence* sequence instance's API, which allows you to vend/fork a new **native `Promise`** that's chained off of your sequence. Use this plugin if you need to send an *asynquence* sequence instance into some other utility which requires a *thenable* or standard [Promises/A+ compliant](http://promisesaplus.com) promise.\n\n**Note:** The vended promise is forked off the sequence, leaving the original sequence intact, to be continuable as normal. The message(s) (both success and error) from the chain are passed along to the promise, but they are *also* retained in the sequence itself, as if the forked-off promise is ignored.\n\n```js\n// make an asynquence sequence to use\nvar sq = ASQ(function(done){\n\tsetTimeout(function(){\n\t\tdone(42);\n\t},100);\n});\n\n// fork and deal with the native promise\nsq.toPromise()\n.then(\n\t// success\n\tfunction(msg){\n\t\tconsole.log(msg); // 42\n\t},\n\t// error\n\tfunction(err){\n\t\tconsole.log(err);\n\t}\n);\n\n// also continue with the original sequence\nsq\n.val(function(msg){\n\tconsole.log(msg); // 42\n});\n```\n\nThe goal of *asynquence* is to provide everything you need for promises-based async flow control without you needing to expose and use native promises or other promise libraries/utilities. Theoretically, this plugin should only be used when *asynquence* is insufficient in some way. If you find yourself needing to regularly vend native promises from *asynquence*, perhaps *asynquence* needs to be extended to handle that use-case, so let us know!\n\n-----\n\nIf you're using *asynquence* in an older environment which doesn't have the native ES6 `Promise` built-in, but you still want to be able to use the `.toPromise()` utility, you need a `Promise` polyfill. There are plenty of choices out there, but a great one to consider is:\n\n[Native Promise Only](http://github.com/getify/native-promise-only)\n\nAs long as either the native `Promise` is there, or that global has been spec-compliant polyfilled, this `toPromise` plugin can create promises off your *asynquence* sequences.\n\n-----\n\n### `errfcb` Plugin\n\n`errfcb` plugin provides `errfcb()` on the main sequence instance API. Unlike other API methods, `errfcb()` **does not return** the main sequence instance (for chaining). Instead, it returns an \"error-first\" style (aka \"node-style\") callback that can be used with any method that expects such a callback.\n\nIf the \"error-first\" callback is then invoked with the first (\"error\") parameter set, the main sequence is flagged for error as usual. Otherwise, the main sequence proceeds as success. Messages sent to the callback are passed through to the main sequence as success/error as expected.\n\n### `runner` Plugin\n\n`runner(..)` takes either an **iterable-sequence** or an ES6 generator function, which will be iterated through step-by-step. `runner(..)` will handle either asynquence sequences, standard promises, or immediate values as the yielded/returned values from the generator or iterable-sequence steps.\n\nThe generator/iterable-sequence will receive any value-messages from the previous sequence step (via the *control token* -- see [CSP-style Concurrency](#csp-style-concurrency) below for explanation), and the final yielded/returned value will be passed along as the success message(s) to the next main sequence step. Error(s) if any will flag the main sequence as error, with error messages passed along as expected.\n\nExamples:\n\n```js\nfunction double(x) {\n\treturn ASQ(function(done){\n\t\tsetTimeout(function(){\n\t\t\tdone(x * 2);\n\t\t},500);\n\t});\n}\n\nASQ(2)\n.runner(function*(token){\n\t// extract message from control-token so\n\t// we can operate on it\n\tvar x = token.messages[0];\n\n\twhile (x < 100) {\n\t\tx = yield double(x);\n\t}\n})\n.val(function(num){\n\tconsole.log(num); // 128\n});\n```\n\n```js\nfunction double(x) {\n\t// standard native Promise\n\treturn new Promise(function(resolve,reject){\n\t\tsetTimeout(function(){\n\t\t\tresolve(x * 2);\n\t\t},500);\n\t});\n}\n\nASQ(2)\n.runner(\n\tASQ.iterable()\n\t.then(function(token){\n\t\t// extract message from control-token so\n\t\t// we can operate on it\n\t\treturn token.messages[0];\n\t})\n\t.then(double)\n\t.then(double)\n\t.then(double)\n)\n.val(function(num){\n\tconsole.log(num); // 16\n});\n```\n\n#### CSP-style Concurrency\n\n`runner(..)` can accept 2 or more generators (or iterable-sequences) that you can cooperatively interleave execution of, which lets you leverage a simple form of CSP-style coroutine concurrency (aka cooperative multitasking\").\n\nGenerators/iterable-sequences will receive a *control token* with a messages channel (`.messages` property is a simple array) to use for passing messages back and forth as the coroutines interleave.\n\nIf you `yield` (or `return` in the case of iterable-sequences) that *control token* back (or a sequence/promise that eventually produces it), then you will signal to transfer control to the next (round-robbin ordering style) generator/sequence in the concurrency-grouping.\n\nOtherwise, yielding/returning of any other type of value, **including a sequence/promise**, will retain control with the current generator/iterator-step.\n\nWith both generators and iterable-sequences, the last *final* non-`undefined` value that is yielded/returned from the concurrency-grouping run will be the forward-passed message(s) to the next step in your main *asynquence* chain. If you want to pass on the channel messages from your generator run, end your last generator by `yield`ing out the `.messages` property of the *control token*. Likewise with iterable-sequences, `return` the channel messages from the last iterable-sequence step.\n\nTo get a better sense of how this advanced functionality works, here's an [example of two generators paired as CSP-style co-routines](https://gist.github.com/getify/10172207).\n\n### `react` Plugin\n\nConsider this kind of ugly code:\n\n```js\n$(\"#button\").click(function(evt){\n   ASQ(this.id)\n   .then(..)\n   .seq(..)\n   .then(..)\n   .val(..)\n});\n```\n\nEach time the button is clicked, a new sequence is defined and executed to \"react\" to the event. But it's a little awkward and ugly that the sequence must be (re)defined each time, *inside* the event listener.\n\nThe `react` plugin separates the capabilities of listening for events and of responding to them, providing first-class syntactic support for the *asynquence* \"reactive sequence\" pattern, inspired by [RxJS Reactive Observables](http://rxjs.codeplex.com/). It essentially combines *asynquence*'s flow-control with repeatable event handling.\n\n1. `react(..)` accepts a listener setup handler, which will receive a reactive trigger (called `proceed` in the snippet below) that event listener(s) \"react\" with by invoking. It will also receive a function you can call one or more times to register a *teardown* handler (to unbind event handlers, etc).\n\n2. The rest of the chain sets up a normal *asynquence* sequence, which will then be repeat-executed each time the reactive trigger is fired. The reactive sequence also has an added `stop()` method, which you can use to trigger any registered teardown handlers and stop all reactive sequence handling.\n\nThe `react` plugin reverses the paradigm of the first snippet, providing a way to specify the sequence externally and once, and have it be re-triggered each time an event fires.\n\n```js\nvar rsq = ASQ.react(\n   // this listener setup handler will be called only once\n   function setup(proceed,registerTeardownHandler){\n      // fire off a new sequence for each click\n      function handler(evt) {\n         // we can call `proceed(..)` (or whatever you want\n         // to call the param!) every time our stream/event\n         // fires, instead of just once like normal promise\n         // resolution\n         proceed(this.id);\n      }\n\n      $(\"#button\").click(handler);\n\n      // register a handler to be called when tearing down\n      // the reactive sequence handling\n      registerTeardownHandler(function(){\n         $(\"#button\").unbind(\"click\",handler);\n      });\n\n      // inside our `setup` handler, `this` will point to\n      // the reactive sequence, which has a `stop()` method\n      // that tears down the reactive sequence handling\n      EVTHUB.on(\"finish\",this.stop);\n   }\n)\n// each time our reactive event fires,\n// process the rest of this sequence\n.then(..)\n.seq(..)\n.then(..)\n.val(..);\n\n// later, to stop the reactive sequence handling:\nEVTHUB.on(\"totally-done\",rsq.stop);\n```\n\nInside the `react(..)` listener setup function, you can set up as many listeners for any kind of events (ajax, timers, click handlers, etc) as you want, and for each, all you need to do to fire off the sequence is call the `proceed(..)` (or whatever you want to name it!) callback. Whatever messages you pass to `proceed(..)` will pass along to the first step of the sequence instance.\n\nThe `proceed` function has two helpers on it for dealing with streams (particularly node streams): `proceed.onStream(..)` and `proceed.unStream(..)`. `onStream(..)` takes one or more streams and subscribes the `data` and `error` events to call the `proceed` function. `unStream(..)` takes one or more streams to unsubscribe, so you would likely use it in a registered teardown handler. For example:\n\n```js\nvar rsq = ASQ.react(function(proceed,registerTeardownHandler){\n\tproceed.onStream( mydatastream );\n\n\tregisterTeardownHandler(function(){\n\t\tproceed.unStream( mydatastream );\n\t});\n})\n.val(function(v){\n\tif (v instanceof Error) throw v;\n\t// ..\n})\n// ..\n.or(function(err){\n\tconsole.log(err);\n});\n```\n\nFor a more real-world type of example, see [reactive sequences + `gate()`](http://jsbin.com/rozipaki/1). Here's [another example](https://gist.github.com/getify/bba5ec0de9d6047b720e), which handles http request/response streams with reactive sequences.\n\n## Using Contrib Plugins\n\nIn the browser, include the `contrib.js` file along with the *asynquence* library file (`asq.js`). Doing so automatically extends the API with the plugins.\n\nIn node.js, you install the `asynquence-contrib` package alongside the `asynquence` package. **Note:** The *asynquence-contrib* package will return the ASQ for you, so you technically only need to this if using both:\n\n```js\n// Note: requiring \"asynquence\" not strictly needed here,\n// since contrib will retrieve and return it automatically\n\nvar ASQ = require(\"asynquence-contrib\");\n```\n\nThey can then be used directly, like this:\n\n```js\nASQ()\n.try(foo)\n.until(bar)\n.then(baz);\n```\n\n## Building Contrib Bundle\n\nThere is a utility provided to bundle the contrib plugins.\n\n`bundle.js` builds the unminified bundle `contrib.src.js`, and then builds (minifies) `contrib.js`. The recommended way to invoke this utility is via npm:\n\n`npm run-script bundle`\n\nBy default, the build includes all the `contrib/plugin.*` plugins. But, you can manually specify which plugins you want, by name, like this:\n\n```\n./bundle.js any none try\n```\n\nThis would bundle only the `any`, `none`, and `try` plugins.\n\n**Note:** `npm run-script ..` [doesn't *currently*](https://github.com/isaacs/npm/issues/3494) support passing the extra command line parameters, so you must use `./bundle.js` **instead of** `npm run-script bundle` if you want to pick which specific plugins to bundle.\n\n## License\n\nThe code and all the documentation, unless otherwise noted, are released under the MIT license.\n\nhttp://getify.mit-license.org/\n",
  "readmeFilename": "README.md",
  "_id": "asynquence-contrib@0.2.3-a",
  "_from": "asynquence-contrib@"
}
